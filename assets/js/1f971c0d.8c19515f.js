"use strict";(self.webpackChunkrimbu_docs=self.webpackChunkrimbu_docs||[]).push([[60905],{3905:function(e,t,n){n.d(t,{Zo:function(){return l},kt:function(){return m}});var r=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=r.createContext({}),s=function(e){var t=r.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=s(e.components);return r.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,p=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),d=s(n),m=o,f=d["".concat(p,".").concat(m)]||d[m]||u[m]||a;return n?r.createElement(f,i(i({ref:t},l),{},{components:n})):r.createElement(f,i({ref:t},l))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var s=2;s<a;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},73203:function(e,t,n){n.d(t,{r:function(){return d}});var r=n(67294),o=Object.defineProperty,a=Object.defineProperties,i=Object.getOwnPropertyDescriptors,c=Object.getOwnPropertySymbols,p=Object.prototype.hasOwnProperty,s=Object.prototype.propertyIsEnumerable,l=(e,t,n)=>t in e?o(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;const u={previewwindow:"console",view:"split",editorsize:"60",codemirror:"1",moduleview:"1"};function d(e){const t=(n=((e,t)=>{for(var n in t||(t={}))p.call(t,n)&&l(e,n,t[n]);if(c)for(var n of c(t))s.call(t,n)&&l(e,n,t[n]);return e})({},u),o={module:`/src/${e.path}`},a(n,i(o)));var n,o;const d=function(e){let t="",n="";for(const r in e)t+=`${n}${r}=${e[r]}`,n="&";return""===t?"":`?${t}`}(t),m=`https://codesandbox.io/embed/github/vitoke/rimbu-sandbox/tree/main${d}`,f=`https://codesandbox.io/s/github/vitoke/rimbu-sandbox/tree/main${d}`;return r.createElement(r.Fragment,null,r.createElement("a",{target:"_blank",className:"button button--secondary",href:f,style:{marginBottom:10}},"Open file below in new window with full type-check"),r.createElement("iframe",{src:m,className:"codesandbox-iframe",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}))}},97077:function(e,t,n){n.r(t),n.d(t,{assets:function(){return h},contentTitle:function(){return f},default:function(){return g},frontMatter:function(){return m},metadata:function(){return b},toc:function(){return y}});var r=n(3905),o=n(73203),a=Object.defineProperty,i=Object.defineProperties,c=Object.getOwnPropertyDescriptors,p=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,l=Object.prototype.propertyIsEnumerable,u=(e,t,n)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,d=(e,t)=>{for(var n in t||(t={}))s.call(t,n)&&u(e,n,t[n]);if(p)for(var n of p(t))l.call(t,n)&&u(e,n,t[n]);return e};const m={id:"deep-patch",slug:"./patch",title:"Deep Patch"},f=void 0,b={unversionedId:"deep/deep-patch",id:"deep/deep-patch",title:"Deep Patch",description:"The Protected function and type allow easy creation of plain objects that cannot be modified in TypeScript. However, it is quite useful to create immutable copies of these objects that change some of its properties.",source:"@site/docs/deep/patch.mdx",sourceDirName:"deep",slug:"/deep/patch",permalink:"/docs/deep/patch",draft:!1,editUrl:"https://github.com/rimbu-org/rimbu/edit/master/website/docs/deep/patch.mdx",tags:[],version:"current",frontMatter:{id:"deep-patch",slug:"./patch",title:"Deep Patch"},sidebar:"sidebar",previous:{title:"Deep Match",permalink:"/docs/deep/match"},next:{title:"Deep Path",permalink:"/docs/deep/path"}},h={},y=[{value:"Usage",id:"usage",level:2}],w={toc:y};function g(e){var t,n=e,{components:a}=n,u=((e,t)=>{var n={};for(var r in e)s.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&p)for(var r of p(e))t.indexOf(r)<0&&l.call(e,r)&&(n[r]=e[r]);return n})(n,["components"]);return(0,r.kt)("wrapper",(t=d(d({},w),u),i(t,c({components:a,mdxType:"MDXLayout"}))),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Protected")," function and type allow easy creation of plain objects that cannot be modified in TypeScript. However, it is quite useful to create immutable copies of these objects that change some of its properties."),(0,r.kt)("p",null,"The main example is Redux state management, which requires any changes to object data to copy the entire object. However, copying deeply nested objects is a lot of work:"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-ts"}),"// update a deeply nested prop without tools\nconst state = {\n  a: 1,\n  b: {\n    c: 'text',\n    d: true,\n  },\n};\n\nconst newState = {\n  ...state,\n  a: state.a + 1,\n  b: {\n    ...state.b,\n    c: 'newText',\n  },\n};\n\n// newState => { a: 2, b: { c: 'newText', d: true } }\n")),(0,r.kt)("p",null,"There are libraries that solve this problem in various ways, for example, the ",(0,r.kt)("a",d({parentName:"p"},{href:"https://github.com/immerjs/immer"}),"Immer")," library allows you to write mutable code that will in the end result in a new object containing those changes."),(0,r.kt)("p",null,"Rimbu offers the ",(0,r.kt)("inlineCode",{parentName:"p"},"patch")," function, which has a kind of 'contract' to specify how a specific object should be updated. The contract uses a quite concise but powerful notation, making it quite handy or many use cases. It also only copies those parts that have changes, and maintains references to the original parts that didn't change."),(0,r.kt)("h2",d({},{id:"usage"}),"Usage"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",d({parentName:"p"},{href:"/api/rimbu/deep"}),(0,r.kt)("inlineCode",{parentName:"a"},"patch"))," function takes the plain (immutable) object to update, and one or more ",(0,r.kt)("inlineCode",{parentName:"p"},"Update")," objects or functions specifying how the object should be updated. It then returns an updated object:"),(0,r.kt)("pre",null,(0,r.kt)("code",d({parentName:"pre"},{className:"language-ts"}),"import { patch, patchNested } from '@rimbu/core';\n\nconst state = {\n  a: 1,\n  b: {\n    c: 'text',\n    d: true,\n  },\n};\n\nconst newState = patch(state, {\n  a: (v) => v + 1,\n  b: patchNested({ c: 'newText' }),\n});\n\n// newState => { a: 2, b: { c: 'newText', d: true } }\n")),(0,r.kt)("p",null,"The following CodeSandbox shows more example of how to use ",(0,r.kt)("inlineCode",{parentName:"p"},"patch"),":"),(0,r.kt)(o.r,{path:"deep/patch.ts",mdxType:"SandBox"}))}g.isMDXComponent=!0}}]);