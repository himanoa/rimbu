"use strict";(self.webpackChunkrimbu_docs=self.webpackChunkrimbu_docs||[]).push([[15324],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),p=c(n),u=r,d=p["".concat(s,".").concat(u)]||p[u]||h[u]||o;return n?a.createElement(d,i(i({ref:t},m),{},{components:n})):a.createElement(d,i({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},87756:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>k,contentTitle:()=>b,default:()=>C,frontMatter:()=>d,metadata:()=>f,toc:()=>g});var a=n(3905),r=Object.defineProperty,o=Object.defineProperties,i=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,s=Object.prototype.hasOwnProperty,c=Object.prototype.propertyIsEnumerable,m=(e,t,n)=>t in e?r(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,p=(e,t)=>{for(var n in t||(t={}))s.call(t,n)&&m(e,n,t[n]);if(l)for(var n of l(t))c.call(t,n)&&m(e,n,t[n]);return e},h=(e,t)=>o(e,i(t)),u=(e,t)=>{var n={};for(var a in e)s.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&l)for(var a of l(e))t.indexOf(a)<0&&c.call(e,a)&&(n[a]=e[a]);return n};const d={title:"@rimbu/channel",slug:"/rimbu/channel"},b="package @rimbu/channel",f={unversionedId:"rimbu_channel/index",id:"rimbu_channel/index",title:"@rimbu/channel",description:"The @rimbu/channel package provides various channel implementations in the spirit of Go. Channels are ways to exechange synchronous messages in an asynchronous context.",source:"@site/api/rimbu_channel/index.mdx",sourceDirName:"rimbu_channel",slug:"/rimbu/channel",permalink:"/api/rimbu/channel",draft:!1,tags:[],version:"current",frontMatter:{title:"@rimbu/channel",slug:"/rimbu/channel"},sidebar:"defaultSidebar",previous:{title:"ContextTypesImpl",permalink:"/api/rimbu/bimultimap/custom/ContextTypesImpl/interface"},next:{title:"Channel (namespace)",permalink:"/api/rimbu/channel/Channel/namespace"}},k={},g=[{value:"Interfaces",id:"interfaces",level:2},{value:"Namespaces",id:"namespaces",level:2}],N={toc:g},y="wrapper";function C(e){var t=e,{components:n}=t,r=u(t,["components"]);return(0,a.kt)(y,h(p(p({},N),r),{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",p({},{id:"package-rimbuchannel"}),(0,a.kt)("inlineCode",{parentName:"h1"},"package @rimbu/channel")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@rimbu/channel")," package provides various channel implementations in the spirit of Go. Channels are ways to exechange synchronous messages in an asynchronous context."),(0,a.kt)("p",null," See the ",(0,a.kt)("a",p({parentName:"p"},{href:"/api/rimbu/channel"}),"Rimbu docs Channel API page")," for more information."),(0,a.kt)("h2",p({},{id:"interfaces"}),"Interfaces"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",p({parentName:"tr"},{align:null}),"Name"),(0,a.kt)("th",p({parentName:"tr"},{align:null}),"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/Channel/interface"}),(0,a.kt)("inlineCode",{parentName:"a"},"Channel<T>"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A Rimbu Channel offers various ways to synchronize communication between asynchronous processes. These processes can send and receive messages in a blocking way. Channel messages are of type T, and channels can be buffered or unbuffered. A buffered channel can queue a given amount of messages before blocking the sender.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/CrossChannel/interface"}),(0,a.kt)("inlineCode",{parentName:"a"},"CrossChannel<TSend,TReceive>"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A CrossChannel is a channel of which the send and receive modules are not internally connected. This means that the send and receive message types can also differ. A normal Channel can receive its own message, but a CrossChannel cannot, and so they are usually created in pairs to perform bidirectional communication with some other entity.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/Mutex/interface"}),(0,a.kt)("inlineCode",{parentName:"a"},"Mutex"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A Mutex is used to restrict access to a shared resource in a concurrent environment. The Mutex can be used to acquire a lock for the resource, preventing others using the Mutext from accessing the resource. When finished using the resource, the lock can be released, allowing other waiting processes to acquire a lock.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/RemoteChannelClient/interface"}),(0,a.kt)("inlineCode",{parentName:"a"},"RemoteChannelClient"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A RemoteChannelClient allows creating channels to communicate with a RemoteChannelServer. The server should be configured to listen to channels with the channel ids provided to the channel creation functions in the client.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/RemoteChannelServer/interface"}),(0,a.kt)("inlineCode",{parentName:"a"},"RemoteChannelServer"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A RemoteChannel server communicates with a RemoteChannel client through the given message port, and allows clients to easily create new channels to communicate with processes in the server context. The server needs to set up handlers to deal with the created channels.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/RpcProxy/interface"}),(0,a.kt)("inlineCode",{parentName:"a"},"RpcProxy<T>"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A remote procedure call proxy that can be used to perform methods on a remote object as though it is accessible locally.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/Semaphore/interface"}),(0,a.kt)("inlineCode",{parentName:"a"},"Semaphore"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A Semaphore is a generalized version of a Mutex, allowing boundaries on the amount of concurrent processes that can have simultaneous access to a shared resource. The semaphore is weighted, meaning that the semaphore has a maximum size/capacity available for the shared resources. When acquiring the resource, a weight can be provided allowing more intensive tasks to acquire a larger share of the shared resource, preventing too many other tasks from also acquiring the resource.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/WaitGroup/interface"}),(0,a.kt)("inlineCode",{parentName:"a"},"WaitGroup"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A WaitGroup is a way to perform fork-join logic in an asynchronous context. It allows a process to create an arbitrary amount of sub-processes, and wait for all of them to finish before continuing.")))),(0,a.kt)("h2",p({},{id:"namespaces"}),"Namespaces"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",p({parentName:"tr"},{align:null}),"Name"),(0,a.kt)("th",p({parentName:"tr"},{align:null}),"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/Channel/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"Channel"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A Rimbu Channel offers various ways to synchronize communication between asynchronous processes. These processes can send and receive messages in a blocking way. Channel messages are of type T, and channels can be buffered or unbuffered. A buffered channel can queue a given amount of messages before blocking the sender.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/ChannelError/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"ChannelError"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"undocumented")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/CrossChannel/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"CrossChannel"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A CrossChannel is a channel of which the send and receive modules are not internally connected. This means that the send and receive message types can also differ. A normal Channel can receive its own message, but a CrossChannel cannot, and so they are usually created in pairs to perform bidirectional communication with some other entity.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/Mutex/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"Mutex"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A Mutex is used to restrict access to a shared resource in a concurrent environment. The Mutex can be used to acquire a lock for the resource, preventing others using the Mutext from accessing the resource. When finished using the resource, the lock can be released, allowing other waiting processes to acquire a lock.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/RemoteChannel/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"RemoteChannel"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A RemoteChannel is a channel that communicates through a message port of the ",(0,a.kt)("inlineCode",{parentName:"td"},"RemoteChannel.SimpleMessagePort")," type. This makes it usable for cross-environment channel communication, e.g. cross threads or even cross network. Like ",(0,a.kt)("inlineCode",{parentName:"td"},"CrossChannel"),", ",(0,a.kt)("inlineCode",{parentName:"td"},"RemoteChannel")," does not receive its own sent messages, but requires another end to communicate.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/RemoteChannelClient/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"RemoteChannelClient"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A RemoteChannelClient allows creating channels to communicate with a RemoteChannelServer. The server should be configured to listen to channels with the channel ids provided to the channel creation functions in the client.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/RemoteChannelServer/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"RemoteChannelServer"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A RemoteChannel server communicates with a RemoteChannel client through the given message port, and allows clients to easily create new channels to communicate with processes in the server context. The server needs to set up handlers to deal with the created channels.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/RemoteObject/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"RemoteObject"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"RemoteObject offers a convenient way to retrieve data and invoke methods across a RemoteChannel. It involves setting up a remote object server that takes a given TypeScript object and allows a remote object client to perform remote calls to this object and getting the results.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/RemoteObjectError/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"RemoteObjectError"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"undocumented")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/RpcProxy/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"RpcProxy"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A remote procedure call proxy that can be used to perform methods on a remote object as though it is accessible locally.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/RpcProxyError/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"RpcProxyError"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"undocumented")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/Semaphore/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"Semaphore"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A Semaphore is a generalized version of a Mutex, allowing boundaries on the amount of concurrent processes that can have simultaneous access to a shared resource. The semaphore is weighted, meaning that the semaphore has a maximum size/capacity available for the shared resources. When acquiring the resource, a weight can be provided allowing more intensive tasks to acquire a larger share of the shared resource, preventing too many other tasks from also acquiring the resource.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/SemaphoreError/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"SemaphoreError"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"undocumented")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",p({parentName:"tr"},{align:null}),(0,a.kt)("a",p({parentName:"td"},{href:"/api/rimbu/channel/WaitGroup/namespace"}),(0,a.kt)("inlineCode",{parentName:"a"},"WaitGroup"))),(0,a.kt)("td",p({parentName:"tr"},{align:null}),"A WaitGroup is a way to perform fork-join logic in an asynchronous context. It allows a process to create an arbitrary amount of sub-processes, and wait for all of them to finish before continuing.")))))}C.isMDXComponent=!0}}]);