<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://rimbu.org/blog</id>
    <title>Rimbu Blog</title>
    <updated>2021-09-03T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://rimbu.org/blog"/>
    <subtitle>Rimbu Blog</subtitle>
    <icon>https://rimbu.org/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[Introducing Rimbu]]></title>
        <id>introducing-rimbu</id>
        <link href="https://rimbu.org/blog/introducing-rimbu"/>
        <updated>2021-09-03T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Immutable collections and tools for TypeScript]]></summary>
        <content type="html"><![CDATA[<h2>Immutable collections and tools for TypeScript</h2><p>A new collection library for TypeScript? Aren&#x27;t <code>Array</code>, <code>Set</code>, and <code>Map</code> good enough? What about <code>immutable.js</code>? Well, I understand you have a lot of questions
my friend. Let me start by describing what Rimbu is all about.</p><h3>Immutability: Create safer code</h3><p>When you start using TypeScript, you are taught it is better to use <code>const</code> where possible instead of <code>let</code> or <code>var</code>. Why is that? Well, mainly because, once you
assign a value with <code>const</code>, you cannot change its value. If you want a new value from that value, you will need to write a new <code>const</code> and give it a new name:</p><pre><code class="language-ts">const a = 5;
a += 1; // Compiler error!
const b = a + 1; // OK
</code></pre><p>However, this principle breaks down when we use referenced values like <code>object</code> or <code>Array</code>. When we assign such a value to a <code>const</code>, we cannot make it <code>null</code>. But we
can change its contents:</p><pre><code class="language-ts">const arr = [1, 2, 3];
arr.length = 0; // this is fine
console.log(arr);
// =&gt; []
</code></pre><p>You see that we can certainly change the value even though we use <code>const</code>. This breaks the whole story about not being able to change <code>const</code> values!</p><p>This is where immutable collections and objects come in to save the day. An immutable object, by definition, cannot be changed. Once it&#x27;s created, its values
will always be the same, no matter what you do to it. Combined with <code>const</code>, we have back our sacred principle of not being able to change assigned values.</p><p>But, I hear you say, what&#x27;s the use? How can we add values to immutable collections? Well, it simply the same as the story of adding 1 to a <code>const</code> number:</p><pre><code class="language-ts">import { List } from &#x27;@rimbu/collections&#x27;;

const list1 = List.of(1, 2, 3);
const list2 = list1.append(4);

console.log(list2.toString());
// =&gt; List(1, 2, 3, 4);
console.log(list1.toString());
// =&gt; List(1, 2, 3);
</code></pre><p>In this example you can clearly see that <code>list2</code> is a new list with other values than <code>list1</code>. Even though we added a value to <code>list1</code>, its contents did
not change. This is exactly the benefit of immutability, you never have to worry about values having changed while you were not looking.</p><h3>Smart and strong type safety</h3><p>Rimbu goes to great lenghts to ensure that the compiler will &#x27;understand&#x27; what you are trying to do, but still prevent you from making obvious mistakes.
For example, imagine the following:</p><pre><code class="language-ts">import { List } from &#x27;@rimbu/collection&#x27;;
const list1 = List.of(1, 2, 3);
// type of list1: List.NonEmpty&lt;number&gt;
const list2 = list1.append(&#x27;a&#x27;); // error: string is not assignable to number
const list3 = list1.extendType&lt;number | string&gt;().append(&#x27;a&#x27;);
// type of list3: List.NonEmpty&lt;number | string&gt;
</code></pre><p>The compiler will rightly prevent you from appending a string to a list of numbers. However, you can still do that without needing to cast using the <code>extendType</code> method.
Furthermore, you see that the lists get type <code>List.NonEmpty</code> instead of <code>List</code>. All Rimbu collections have this type information to indicate whether the compiler can know at
compile time that the collection has at least one value. This allows us to write code that by definition rejects empty collections, and saves us from having to write
checks for empty collections and thinking about how to handle such situations. In particular, it saves us from writing boring tests.</p><p>These are just small examples from a plethora of built-in smartness that the Rimbu collections possess.</p><h3>Performance: Rimbu collections designed for performance</h3><p>Because immutable collections are often described as &#x27;copying&#x27; data, they are often assumed to be slow. However, there is a principle called &#x27;persistence&#x27;, which
allows them to actually be really fast. Persistance actually means memory sharing. Rimbu immutable collections will share memory as much as possible as long as no
changes need to be made. The collections only duplicates parts of shared data that are modified. The rest of the data remains shared. This is because the collections
keep their data in block-like structures, comparable to blocks on hard-drives. If some collection uses 50 blocks of data, and one value is changed, chances are that only 2 or 3 blocks need to be copied and changed, while the rest stays the same and shared. In some cases, persistent collections can be faster than mutable collections. For example, reversing a <code>List</code> of N elements in Rimbu has complexity O(logM(N)) where M is usually 32, so it is really fast for large collections as well. For a mutable array, the complexity is O(N), and therefore much slower. A similar story goes for memory complexity, however I will probably cover this topic some other time.</p><h3>Simplicity</h3><p>Rimbu is mostly about giving the programmer new powerful tools to write safe and effective programs that are simple. For example, it avoids using advanced functional
programming concepts like Monads, because they make code harder to understand and read.</p><p>This is why you will not find an <code>Option</code> or <code>Maybe</code> type (which are monads). Still, Rimbu provides nearly the same power in all methods that can fail:</p><pre><code class="language-ts">import { List, err } from &#x27;@rimbu/core&#x27;;

const list = List.of(1, 2, 3);

const v1 = list.getAtIndex(1);
// type of v1: number | undefined

const v2 = list.getAtIndex(1, &#x27;not found&#x27;);
// type of v2: number | &#x27;not found&#x27;

const v3 = list.getAtIndex(1, -1); // return -1 if not found
// type of v3: number

const v4 = list.getAtIndex(1, () =&gt; &#x27;lazy failure&#x27;);
// type of v4: number | &#x27;lazy failure&#x27;

// err is a function that throws an error when invoked
const v5 = list.getAtIndex(1, err);
// type of v5: number
</code></pre><p>In this way it is not needed to write things like <code>list.getOption(..).map(..).getOrElse(..)</code> or <code>if (list.get(1) === undefined) throw Error()</code></p><h3>But still, what about <code>immmutable.js</code>?</h3><p>Of course we already have a very nice JavaScript immutable collection library for years, called <code>immutable.js</code>. To be honost, I&#x27;ve never used it myself in projects,
but I have read their documentation. The first thing that strikes me, in comparison to Rimbu, is that <code>immutable.js</code> is focused firstly on JavaScript and
added types later on. Secondly, it has a few basic collections, like Maps and Sets, but Rimbu has many more (up to <code>Graphs</code>). Finally, it has <code>Records</code> to
define immutable objects. However, with TypeScript, we can use the compiler to supply deep readonly types that prevent modification of plain objects. In this way
this is a very lightweight and easier to use approach.</p><h3>What&#x27;s to come?</h3><p>In the coming time, I want to write much more documentation, and I hope to receive feedback on the current state of the library from other users. If there
are requests for other types of collections, I would be willing to implement them and add them to the library.</p>]]></content>
        <author>
            <name>Arvid Nicolaas</name>
            <uri>https://github.com/vitoke</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[How it all got started]]></title>
        <id>how-it-got-started</id>
        <link href="https://rimbu.org/blog/how-it-got-started"/>
        <updated>2021-09-02T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[In my Scala days, I became very interested in immutable collections, especially Scala's Vector. I was watching all kinds of YouTube videos from conferences]]></summary>
        <content type="html"><![CDATA[<p>In my Scala days, I became very interested in immutable collections, especially Scala&#x27;s Vector. I was watching all kinds of YouTube videos from conferences
that discussed how it works, and why it offers reasonably fast random access (debatably called effectively constant time). At the same time, I discovered that the Vector did not have an <code>insert</code> or <code>remove</code>
method, and I wondered why. I started investigating how the data structure works, and read papers with proposals on how to improve the structure to allow random
insertion. I also started getting ideas on how it could be done differently and started implementing my own structure.</p><p>This was going slowly but I was progressing. And while I was doing that, I also found ways to have better typed methods for collections in Scala. I thought I might
as well create a whole collection library instead of just one collection implementation. I learned a lot from this effort about immutable data structures and
creating strict but useful types. However, after some time, I realized that Scala, while having a great compiler, was holding me back in writing the code I wanted
to write. Also, it seemed the community was getting split (due to a complete rewrite of Scala), and its popularity seemed to go down. In the meantime, Scala does have
a new Vector implementation with the <code>insert</code> and <code>remove</code> methods. I actually discovered this quite recently. However, I found the documentation of the structure lacking so I cannot compare it to my approach.</p><p>Since I was now using TypeScript at work, it seemed an interesting exercise to me to see if I could better write down my ideas in this language. It turned out
that this was indeed the case. And stil, I could create quite rich interfaces for the collection methods. This led me to abandon the Scala effort, and fully
focus on the TypeScript library (I basically ported/rewrote the Scala code to TypeScript). And now, I have (finally) released the Rimbu library.</p><p>There are many things still to be done, but I am satisfied with the library so far. I hope developers will find it useful for their own projects, and am
hopeful to hear what they think of it. I hope to find time to extensively document the data structure behind Rimbu&#x27;s List in the near future. I find it quite
a remarkable data structure myself. I hope to write some blogs as well on interesting use cases I found for the various collections. Stay tuned!</p>]]></content>
        <author>
            <name>Arvid Nicolaas</name>
            <uri>https://github.com/vitoke</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Introducing Myself]]></title>
        <id>introducing-myself</id>
        <link href="https://rimbu.org/blog/introducing-myself"/>
        <updated>2021-09-01T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Programming has, from a young age, been one of my passions. I remember starting in the early days in Basic. It felt like magic, being able to write]]></summary>
        <content type="html"><![CDATA[<p>Programming has, from a young age, been one of my passions. I remember starting in the early days in Basic. It felt like magic, being able to write
infinitely many programs to do all kinds of fun and useful things. As I grew better at it, I remember my programs began to get larger as well. Soon,
I discovered that the limited support for subroutines (primitive procedures) quickly made a mess of my programs, and I lost oversight.</p><p>Then I moved on to Turbo Pascal. Again, I was really happy with the way I could use modules, functions and procedures to better structure my code, so I could
scale my programs up without everything becoming one big mess, but it still had its limits. It wasn&#x27;t until university that I really became aware of
the importance of structured programming to keep complexity at bay. I became really interested (as many I guess) in pure functional programming, and actually
did my Master&#x27;s Degree in this topic. Composing functions and having no mutability were things that really struck me as being game changers for scaling programs.</p><p>Then, after university, reality kicked in: almost no company was (is?) using pure functional programming. So I went back to Java, C#, etc. I did spend a lot of my
free time using Scala, which I still think has a great mixture of different paradigms, including immutable collections. But Scala, unfortunately, was
also not really used inside the company.</p><p>Then the projects I worked on for my company led me to learn JavaScript, and later TypeScript. It was not love at first sight,
but TypeScript, being a quickly evolving language with unique takes on types and soundness, did quickly resonate with me. It&#x27;s far, very far, from perfect, but
in return it is extremely expressive, especially concerning types. The sole support of union types makes any other language that doesn&#x27;t have that feature
feel like a major step back.</p><p>So after many years, programming is still my passion. And with TypeScript I am able to express most of my needs, even though it also often requires work-arounds
or tricks that slow the compiler down quite a bit. I hope the language will continue to evolve and thrive, but especially improve. I like the fact that there
are new developments like NativeScript to take the language out of the JavaScript sandbox. Unfortunately, NativeScript had to drop support for union types,
which makes it a no go for me. I am really excited about Deno, a follow-up of Node built on Rust, and hope it will grow.</p><p>Did I expect TypeScript to be my go-to language a few years back? Definitely no. But right now I think it is the best language for me to write what I
want to write, like, for example, the Rimbu Immutable Collections library.</p>]]></content>
        <author>
            <name>Arvid Nicolaas</name>
            <uri>https://github.com/vitoke</uri>
        </author>
    </entry>
</feed>